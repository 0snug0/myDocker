user  nginx;
worker_processes  auto;
error_log  /var/log/nginx/error.log notice;
pid        /var/run/nginx.pid;
 
 
events {
    worker_connections  1024;
}
 
http {
   client_body_in_file_only clean;
   client_body_buffer_size 32K;
   client_max_body_size 300M;
   sendfile on;
   send_timeout 300s;
 
    match pingok {
        # used for /?ping health check
        status 200;
        header Content-Type = text/html;
        body ~ "Data Node is Available";
    }
 
    upstream s3backend {
        zone s3backend 64k;
          # server 127.0.0.1:8006;
        server 10.64.253.161:9020       weight=1;
        server 10.64.253.162:9020       weight=1;
        server 10.64.253.163:9020       weight=1;
        server 10.64.253.164:9020       weight=1;
    }
 
    # upstream swiftbackend {
    #     zone swiftbackend 64k;
    #     server 10.64.253.161:9024       weight=1;
    #     server 10.64.253.162:9024       weight=1;
    #     server 10.64.253.163:9024       weight=1;
    #     server 10.64.253.164:9024       weight=1;
    # }
 
 
    server {
          listen *:80;
          ignore_invalid_headers off;
          underscores_in_headers on;
          server_name *.s3.ecs.test;
          status_zone s3backend;
          location / {
                proxy_pass      http://s3backend;
                proxy_http_version      1.1;
                proxy_set_header Host $host;
                access_log s3.access.log;
                error_log s3.error.log;
          }
          # location @ping {
          #       internal;
          #       proxy_pass http://s3backend;
          #       health_check uri=/?ping;
          #       proxy_set_header x-emc-namespace lsc;
          # }
    }
 
    server {
          listen *:443 ssl;
          server_name *.s3.ecs.test;
          status_zone s3backend;
          ssl_certificate /etc/nginx/ssl/server.crt;
          ssl_certificate_key /etc/nginx/ssl/ecs.test.key;
          ssl_protocols TLSv1.2;
          location / {
                proxy_pass      http://s3backend;
                proxy_http_version      1.1;
                proxy_set_header Host $host;
                access_log s3.access.log;
                error_log s3.error.log;
          }
          location @ping {
                internal;
                proxy_pass http://s3backend;
                health_check uri=/?ping;
                proxy_set_header x-emc-namespace lsc;
          }
    }
 
   # server {
   #         listen *:81;
   #         status_zone swiftbackend;
   #         location / {
   #                  proxy_pass  http://swiftbackend;
   #                  proxy_set_header Host $host;
   #                  access_log swift.access.log;
   #                  error_log swift.error.log;
           # }
   # }
 
   #  server {
   #        listen *:444 ssl;
   #        server_name s3.ecs.test;
   #        status_zone swiftbackend;
   #        ssl_certificate /etc/nginx/ssl/server.crt;
   #        ssl_certificate_key /etc/nginx/ssl/ecs.test.key;
   #        ssl_protocols TLSv1.2;
   #        location / {
   #              proxy_pass      http://swiftbackend;
   #              proxy_set_header Host $host;
   #              access_log swift.access.log;
   #              error_log swift.error.log;

   #        }
   #  }
 
   # server       {
   #        listen 8080;
   #        root  /usr/share/nginx/html;
   #        # Redirect    requests for / to       /status.html

   #        location = / {
   #              return 301      /status.html;
   #       }
   #       location =     /status.html { }
   #       # Everything beginning /status (except for /status.html) is
   #       # processed by the status handler
   #       location /status       {
   #              status;
   #       }
   # }
}

location / {
  include iprules.d/site1.conf
}













